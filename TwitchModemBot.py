import socket
import subprocess
import time
import threading
import re
from collections import deque

# === Twitch Bot Settings ===
TWITCH_CHANNEL = "STREAMER CHANNEL HERE"       # Streamer's channel
BOT_NICK = "BOTNAME HERE"           # Bot's username
BOT_OAUTH = "OAUTH:TOKEN HERE"
BOT_SERVER = "irc.chat.twitch.tv"
BOT_PORT = 6667

# === Moderators/Streamer (all in lowercase) ===
MODERATORS = ["TwitchStreamerUsernameHere", "YourBotusernameHere", "SomeRandomModHere"]

# === Interface Mappings ===
INTERFACES = {
    "wlan0": "Verizon",
    "wlan1": "T-Mobile",
    "wlan2": "AT&T",
    "wlan3": "Dish",
    "wlan4": "Starlink",
    "connectify0": "Speedify"
}

# === Command-to-Interface Mappings (for per-interface commands) ===
INTERFACE_COMMANDS = {
    # Long form speedtest commands
    "!speedtestverizon": "wlan0",
    "!speedtesttmobile": "wlan1",
    "!speedtestatt": "wlan2",
    "!speedtestdish": "wlan3",
    "!speedteststarlink": "wlan4",
    "!speedtestspeedify": "connectify0",
    # Regular TX/RX commands
    "!verizon": "wlan0",
    "!tmobile": "wlan1",
    "!att": "wlan2",
    "!dish": "wlan3",
    "!starlink": "wlan4",
    "!speedify": "connectify0",
    # Shorter speedtest commands:
    "!speedverizon": "wlan0",
    "!speedtmobile": "wlan1",
    "!speedatt": "wlan2",
    "!speeddish": "wlan3",
    "!speedstar": "wlan4",
    "!speedsify": "connectify0"
}

# Define a set of commands that should run a speedtest.
SPEEDTEST_COMMANDS = {
    "!speedtestverizon", "!speedtesttmobile", "!speedtestatt", "!speedtestdish", "!speedteststarlink", "!speedtestspeedify",
    "!speedverizon", "!speedtmobile", "!speedatt", "!speeddish", "!speedstar", "!speedsify"
}

# === Speed History Storage ===
SPEED_HISTORY = {iface: deque(maxlen=5) for iface in INTERFACES.keys()}

# === Global dictionary to store last connectivity state for each interface.
interface_state = {}

# === Helper Functions ===

def is_moderator(user):
    mod = user.lower() in [m.lower() for m in MODERATORS]
    print(f"[DEBUG] is_moderator check for user '{user}': {mod}")
    return mod

def parse_speedtest_output(output, provider_name):
    """
    Parses the Ookla Speedtest CLI output and extracts only the latency,
    download speed, and upload speed.
    """
    # Look for latency, download, and upload using regex.
    latency_match = re.search(r"Idle Latency:\s+([\d.]+)\s*ms", output)
    download_match = re.search(r"Download:\s+([\d.]+)\s+Mbps", output)
    upload_match = re.search(r"Upload:\s+([\d.]+)\s+Mbps", output)
    if latency_match and download_match and upload_match:
        latency = latency_match.group(1)
        download = download_match.group(1)
        upload = upload_match.group(1)
        return f"Speedtest for {provider_name} - Latency: {latency} ms, Download: {download} Mbps, Upload: {upload} Mbps"
    else:
        # If regex fails, try to remove the Result URL line and return a shortened version.
        lines = output.splitlines()
        filtered = [line for line in lines if not line.strip().startswith("Result URL:")]
        # Attempt to find download and upload values in a simpler way.
        # This is a fallback.
        return f"Speedtest for {provider_name} - { ' | '.join(filtered) }"

def run_speedtest(interface):
    try:
    # Running a Speedtest overwrites /etc/resolv.conf since Speedify regenerates it with its own DNS, causing host resolution issues. This ensures /etc/resolv.conf updates each time Speedtest runs. - edit to your own preferred DNS (or connect all your personal devices then copy your resolv.conf and modify the DNS below!)
        dns_config = """\
nameserver 1.1.1.1
nameserver 10.202.0.1
nameserver 8.8.8.8
# Generated by NetworkManager
search net lan
nameserver 10.168.1.1
nameserver fc00:a:a::300
nameserver 11.168.1.1
# NOTE: the libc resolver may not support more than 3 nameservers.
# The nameservers listed below may not be recognized.
nameserver 192.168.170.1
nameserver fe80::6c96:6aff:fe82:20b4%wlan0
nameserver 192.168.69.1
nameserver fe80::6088:8eff:fe26:4de9%wlan1
nameserver 192.168.1.1
nameserver fd7d:82a9:4ccc:10::1
"""

    # Step 1: Write the DNS settings to /etc/resolv.conf (requires sudo)
        subprocess.run(["sudo", "bash", "-c", f'echo "{dns_config}" | tee /etc/resolv.conf'], check=True)

    # Step 2: Restart networking service (optional, depends on your OS)
        subprocess.run(["sudo", "systemctl", "restart", "networking"], check=True)

    # Step 3: Run the speed test
        # Use the official Ookla Speedtest CLI with the equals syntax and required non-interactive flags.
        cmd = ["speedtest", f"--interface={interface}", "--accept-license", "--accept-gdpr"]
        print(f"[DEBUG] Running command: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
        print(f"[DEBUG] Command finished with return code {result.returncode}")
        if result.returncode != 0:
            print(f"[ERROR] Speedtest error: {result.stderr.strip()}")
            return f"Speedtest failed for {INTERFACES.get(interface, interface)}: {result.stderr.strip()}"
        output = result.stdout.strip()
        print(f"[DEBUG] Full speedtest output:\n{output}")
        if not output:
            print(f"[ERROR] No output received: {result.stderr.strip()}")
            return f"Speedtest returned no output for {INTERFACES.get(interface, interface)}. {result.stderr.strip()}"
        SPEED_HISTORY[interface].append(output)
        # Parse the output to only include latency, download, and upload speed.
        parsed_output = parse_speedtest_output(output, INTERFACES.get(interface, interface))
        return parsed_output
    except Exception as e:
        print(f"[EXCEPTION] run_speedtest: {e}")
        return f"Error running speedtest for {INTERFACES.get(interface, interface)}: {e}"

def get_network_speed(interface):
    """
    Measures TX and RX speeds over a 1-second interval (in Kbps).
    It reads the current byte counters, waits 1 second, then computes the difference.
    """
    try:
        with open(f"/sys/class/net/{interface}/statistics/tx_bytes", "r") as f:
            tx1 = int(f.read())
        with open(f"/sys/class/net/{interface}/statistics/rx_bytes", "r") as f:
            rx1 = int(f.read())
        time.sleep(1)
        with open(f"/sys/class/net/{interface}/statistics/tx_bytes", "r") as f:
            tx2 = int(f.read())
        with open(f"/sys/class/net/{interface}/statistics/rx_bytes", "r") as f:
            rx2 = int(f.read())
        diff_tx = tx2 - tx1
        diff_rx = rx2 - rx1
        # Convert bytes/second to kilobits per second: (bytes * 8) / 1024
        speed_tx = diff_tx * 8 / 1024
        speed_rx = diff_rx * 8 / 1024
        print(f"[DEBUG] {INTERFACES.get(interface, interface)} TX: {speed_tx:.2f} Kbps, RX: {speed_rx:.2f} Kbps")
        return speed_tx, speed_rx
    except Exception as e:
        print(f"[EXCEPTION] get_network_speed for {interface}: {e}")
        return 0, 0

def get_status():
    """
    Returns a status string for all interfaces that includes:
      - Provider name
      - TX and RX speeds in Kbps
      - Status icon: OK (✅), SLOW (⚠️), or DOWN (❌)
    """
    status_message = "Network Status: "
    for interface in INTERFACES.keys():
        tx_speed, rx_speed = get_network_speed(interface)
        provider = INTERFACES[interface]
        if tx_speed == 0 and rx_speed == 0:
            status_message += f"{provider}: TX: {tx_speed:.2f} Kbps, RX: {rx_speed:.2f} Kbps - DOWN ❌ | "
        elif tx_speed < 5000 or rx_speed < 5000:
            status_message += f"{provider}: TX: {tx_speed:.2f} Kbps, RX: {rx_speed:.2f} Kbps - SLOW ⚠️ | "
        else:
            status_message += f"{provider}: TX: {tx_speed:.2f} Kbps, RX: {rx_speed:.2f} Kbps - OK ✅ | "
    return status_message.rstrip(" | ")

def send_twitch_message(sock, message):
    # Split message into chunks if longer than 450 characters.
    max_length = 450
    chunks = [message[i:i+max_length] for i in range(0, len(message), max_length)]
    for chunk in chunks:
        print(f"[CHAT] {chunk}")
        sock.send(f"PRIVMSG #{TWITCH_CHANNEL} :{chunk}\r\n".encode("utf-8"))
        time.sleep(1)  # slight delay to avoid rate limits

# === Connectivity Monitoring Function ===
def monitor_connectivity(sock):
    """
    Periodically checks the operstate of each interface.
    If an interface's state changes, it sends a message in chat indicating the change.
    """
    global interface_state
    # Initialize states.
    for iface in INTERFACES.keys():
        try:
            with open(f"/sys/class/net/{iface}/operstate", "r") as f:
                state = f.read().strip()
        except:
            state = "unknown"
        interface_state[iface] = state
        print(f"[DEBUG] Initial state for {INTERFACES.get(iface, iface)}: {state}")

    while True:
        for iface in INTERFACES.keys():
            try:
                with open(f"/sys/class/net/{iface}/operstate", "r") as f:
                    current_state = f.read().strip()
            except:
                current_state = "unknown"
            previous_state = interface_state.get(iface, "unknown")
            if current_state != previous_state:
                interface_state[iface] = current_state
                provider = INTERFACES.get(iface, iface)
                if current_state == "up":
                    msg = f"{provider} is now connected ✅"
                else:
                    msg = f"{provider} is no longer connected ❌"
                print(f"[DEBUG] Connectivity change for {provider}: {msg}")
                send_twitch_message(sock, msg)
        time.sleep(10)

# === Command Handler ===
def handle_chat_command(sock, user, command):
    print(f"[DEBUG] Received command '{command}' from user '{user}'")
    # First, handle commands that are independent of INTERFACE_COMMANDS.
    if command == "!modem":
        status = get_status()
        print(f"[DEBUG] Status: {status}")
        send_twitch_message(sock, status)
        return
    elif command.startswith("!speedhistory"):
        arg = command[len("!speedhistory"):].strip()  # e.g., "att" or "verizon"
        provider_aliases = {
            "verizon": "Verizon",
            "tmobile": "T-Mobile",
            "att": "AT&T",
            "dish": "Dish",
            "starlink": "Starlink",
            "speedify": "Speedify"
        }
        if arg in provider_aliases:
            provider_name = provider_aliases[arg]
            iface = None
            for key, val in INTERFACES.items():
                if val.lower() == provider_name.lower():
                    iface = key
                    break
            if iface:
                history = SPEED_HISTORY.get(iface, [])
                msg = f"Last 5 Speedtests for {provider_name}: {' | '.join(history) if history else 'No data yet'}"
                print(f"[DEBUG] {msg}")
                send_twitch_message(sock, msg)
            else:
                send_twitch_message(sock, "Invalid interface for speed history.")
        else:
            send_twitch_message(sock, "Invalid interface for speed history.")
        return
    elif command == "!pingfiber":
        print("[DEBUG] Running ping for Fiber")
        result = subprocess.run(["ping", "-c", "4", "PUT YOUR DDNS/Domain Here"], capture_output=True)
        msg = "Connection to Fiber is stable." if result.returncode == 0 else "Connection to Fiber is unstable."
        print(f"[DEBUG] Ping fiber result: {msg}")
        send_twitch_message(sock, msg)
        return
    elif command == "!pingcoax":
        print("[DEBUG] Running ping for Coax")
        result = subprocess.run(["ping", "-c", "4", "PUT YOUR DDNS/Domain Here"], capture_output=True)
        msg = "Connection to Coax is stable." if result.returncode == 0 else "Connection to Coax is unstable."
        print(f"[DEBUG] Ping coax result: {msg}")
        send_twitch_message(sock, msg)
        return
    elif command == "!topspeed":
        best_speed = 0
        best_provider = "None"
        for iface in INTERFACES.keys():
            tx_speed, rx_speed = get_network_speed(iface)
            total_speed = tx_speed + rx_speed
            if total_speed > best_speed:
                best_speed = total_speed
                best_provider = INTERFACES[iface]
        msg = f"Fastest Network: {best_provider} at {best_speed:.2f} Kbps"
        print(f"[DEBUG] {msg}")
        send_twitch_message(sock, msg)
        return
    elif command.startswith("!usage"):
        send_twitch_message(sock, "Data usage tracking not implemented yet.")
        return

    # Now handle commands that are in INTERFACE_COMMANDS.
    if command in INTERFACE_COMMANDS:
        interface = INTERFACE_COMMANDS[command]
        # If the command is one of the speedtest commands (long or short form)
        if command in SPEEDTEST_COMMANDS:
            if not (is_moderator(user) or user.lower() == BOT_NICK.lower()):
                send_twitch_message(sock, "You don't have permission to run this command.")
                return
            provider_name = INTERFACES.get(interface, interface)
            print(f"[DEBUG] Running speedtest for {provider_name}")
            send_twitch_message(sock, f"Running speedtest for {provider_name}...")
            result = run_speedtest(interface)
            result = result.replace(f"Speedtest for {interface}", f"Speedtest for {provider_name}")
            print(f"[DEBUG] Speedtest result: {result}")
            send_twitch_message(sock, result)
        else:
            tx_speed, rx_speed = get_network_speed(interface)
            msg = f"{INTERFACES[interface]} TX: {tx_speed:.2f} Kbps, RX: {rx_speed:.2f} Kbps"
            print(f"[DEBUG] {msg}")
            send_twitch_message(sock, msg)
    if command == "!reboot" and is_moderator(user):
        print("[DEBUG] Reboot command recognized")
        send_twitch_message(sock, "Rebooting now 🔄")
        subprocess.run(["sudo", "reboot"])
    
    elif command == "!shutdown" and is_moderator(user):
        print("[DEBUG] Shutdown command recognized")
        send_twitch_message(sock, "Shutting down now 🛑")
        subprocess.run(["sudo", "shutdown", "now"])
    else:
        print(f"[DEBUG] Unknown command: {command}")
        # Unknown command – do nothing.
        pass
# === Twitch Connection Functions ===
def connect_to_twitch():
    try:
        sock = socket.socket()
        sock.connect((BOT_SERVER, BOT_PORT))
        sock.send(f"PASS {BOT_OAUTH}\r\n".encode("utf-8"))
        sock.send(f"NICK {BOT_NICK}\r\n".encode("utf-8"))
        sock.send(f"JOIN #{TWITCH_CHANNEL}\r\n".encode("utf-8"))
        send_twitch_message(sock, "Back online! ✅")
        print("[DEBUG] Connected to Twitch IRC")
        return sock
    except Exception as e:
        print(f"[ERROR] Could not connect to Twitch: {e}")
        exit(1)

def main():
    twitch_sock = connect_to_twitch()
    threading.Thread(target=monitor_connectivity, args=(twitch_sock,), daemon=True).start()
    while True:
        try:
            response = twitch_sock.recv(1024).decode("utf-8")
        except Exception as e:
            print(f"[ERROR] Error receiving data: {e}")
            continue
        if "PING" in response:
            print("[DEBUG] Received PING, sending PONG")
            twitch_sock.send("PONG\r\n".encode("utf-8"))
        if f"PRIVMSG #{TWITCH_CHANNEL}" in response:
            try:
                user = response.split("!")[0][1:]
                message = response.split("PRIVMSG #" + TWITCH_CHANNEL + " :")[1].strip()
                print(f"[DEBUG] Chat message from {user}: {message}")
            except IndexError:
                continue
            if message.startswith("!"):
                handle_chat_command(twitch_sock, user, message.lower())

if __name__ == "__main__":
    main()
